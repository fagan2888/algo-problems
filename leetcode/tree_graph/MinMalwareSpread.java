import java.util.*;

import org.junit.Test;
import static org.junit.Assert.*;

import common.DisjointSet;

// LC924: https://leetcode.com/problems/minimize-malware-spread/
//
// In a network of nodes, each node i is directly connected to another node j if
// and only if graph[i][j] = 1. Some nodes initial are initially infected by
// malware.  Whenever two nodes are directly connected and at least one of those
// two nodes is infected by malware, both nodes will be infected by malware.
// This spread of malware will continue until no more nodes can be infected in
// this manner. Suppose M(initial) is the final number of nodes infected with
// malware in the entire network, after the spread of malware stops.
// We will remove one node from the initial list.  Return the node that if
// removed, would minimize M(initial).  If multiple nodes could be removed to
// minimize M(initial), return such a node with the smallest index.
// Note that if a node was removed from the initial list of infected nodes, it
// may still be infected later as a result of the malware spread.
public class MinMalwareSpread {
    // Union Find
    // time complexity: O(N ^ 2), space complexity: O(N)
    // beats 88.70%(14 ms for 51 tests)
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        DisjointSet ds = new DisjointSet(n);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) {
                    ds.union(i, j);
                }
            }
        }
        Arrays.sort(initial);
        int res = -1;
        int min = n + 1;
        for (int i : initial) {
            int cur = infected(ds, initial, i);
            if (cur < min) {
                min = cur;
                res = i;
            }
        }
        return res;
    }

    private int infected(DisjointSet ds, int[] initial, int excluded) {
        int[] id = ds.getParent();
        Set<Integer> counted = new HashSet<>();
        int res = 0;
        for (int v : initial) {
            if (v == excluded) continue;

            int root = id[v];
            while (root >= 0) {
                root = id[root];
            }
            if (counted.add(root)) {
                res -= root;
            }
        }
        return res;
    }

    // Union Find
    // time complexity: O(N ^ 2), space complexity: O(N)
    // beats 69.67%(20 ms for 51 tests)
    public int minMalwareSpread2(int[][] graph, int[] initial) {
        int n = graph.length;
        DSU dsu = new DSU(n);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) {
                    dsu.union(i, j);
                }
            }
        }
        int[] count = new int[n];
        for (int node : initial) {
            count[dsu.find(node)]++;
        }
        int res = -1;
        int maxSize = -1;
        for (int node : initial) {
            int root = dsu.find(node);
            if (count[root] != 1) continue;

            int rootSize = dsu.size(root);
            if (rootSize > maxSize || (rootSize == maxSize && node < res)) {
                maxSize = rootSize;
                res = node;
            }
        }
        if (res == -1) {
            res = Integer.MAX_VALUE;
            for (int node : initial)
                res = Math.min(res, node);
        }
        return res;
    }

    class DSU {
        private int[] id;
        private int[] size;

        DSU(int n) {
            id = new int[n];
            for (int x = 0; x < n; x++) {
                id[x] = x;
            }
            size = new int[n];
            Arrays.fill(size, 1);
        }

        public int find(int x) {
            if (id[x] != x) {
                id[x] = find(id[x]);
            }
            return id[x];
        }

        public void union(int x, int y) {
            int xRoot = find(x);
            int yRoot = find(y);
            id[xRoot] = yRoot;
            size[yRoot] += size[xRoot];
        }

        public int size(int x) {
            return size[find(x)];
        }
    }

    // DFS + Recursion
    // time complexity: O(N ^ 2), space complexity: O(N)
    // beats 88.70%(14 ms for 51 tests)
    public int minMalwareSpread3(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] colors = new int[n];
        Arrays.fill(colors, -1);
        int C = 0;
        for (int node = 0; node < n; node++) {
            if (colors[node] == -1) {
                dfs(graph, colors, node, C++);
            }
        }
        int[] size = new int[C];
        for (int color : colors) {
            size[color]++;
        }
        int[] colorCount = new int[C];
        for (int node : initial) {
            colorCount[colors[node]]++;
        }
        int res = Integer.MAX_VALUE;
        for (int node : initial) {
            int c = colors[node];
            if (colorCount[c] == 1) {
                if (res == Integer.MAX_VALUE) {
                    res = node;
                } else if (size[c] > size[colors[res]]) {
                    res = node;
                } else if (size[c] == size[colors[res]] && node < res) {
                    res = node;
                }
            }
        }
        if (res == Integer.MAX_VALUE) {
            for (int node : initial) {
                res = Math.min(res, node);
            }
        }
        return res;
    }

    private void dfs(int[][] graph, int[] colors, int node, int color) {
        colors[node] = color;
        for (int nei = 0; nei < graph.length; nei++) {
            if (graph[node][nei] == 1 && colors[nei] == -1) {
                dfs(graph, colors, nei, color);
            }
        }
    }

    void test(int[][] graph, int[] initial, int expected) {
        assertEquals(expected, minMalwareSpread(graph, initial));
        assertEquals(expected, minMalwareSpread2(graph, initial));
        assertEquals(expected, minMalwareSpread3(graph, initial));
    }

    @Test
    public void test() {
        test(new int[][] {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, new int[] {0, 1}, 0);
        test(new int[][] {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, new int[] {0, 2}, 0);
        test(new int[][] {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, new int[] {1, 2}, 1);
    }

    public static void main(String[] args) {
        String clazz = new Object() {}.getClass().getEnclosingClass().getSimpleName();
        org.junit.runner.JUnitCore.main(clazz);
    }
}
