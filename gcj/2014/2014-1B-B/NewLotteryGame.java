import java.util.*;
import java.io.*;

import org.junit.Test;
import static org.junit.Assert.*;

// https://code.google.com/codejam/contest/2994486/dashboard#s=p1
// Round 1B 2014: Problem B - New Lottery Game
//
// The Lottery's new winning number will be the result of the bitwise-AND
// operation between the two random numbers generated by the two machines.
// The old machine will always generate a non-negative integer less than A and 
// the new one will always generate a non-negative integer less than B. You want
// to win this lottery and decide to buy all non-negative integers less than K.
// Given A, B and K, you would like to know in how many different ways the
// machines can generate a pair of numbers that will make her a winner.
// Input
// The first line of the input gives the number of test cases, T. T lines
// follow, each line with three numbers A B K.
// Output
// For each test case, output one line containing "Case #x: y", where x is the
// test case number (starting from 1) and y is the number of possible pairs that
// the machines can generate to make you a winner.
// Limits
// 1 ≤ T ≤ 100.
// Small dataset
// 1 ≤ A ≤ 1000.
// 1 ≤ B ≤ 1000.
// 1 ≤ K ≤ 1000.
// Large dataset
// 1 ≤ A ≤ 10 ^ 9.
// 1 ≤ B ≤ 10 ^ 9.
// 1 ≤ K ≤ 10 ^ 9.
public class NewLotteryGame {
    // consider the least significant bit
    // Recursion + Dynamic Programming(Top-Down)
    // time complexity: O(LOG(MAX(A, B)))
    public static long win(int A, int B, int K) {
        return win(A, B, K, new HashMap<>());
    }

    private static long win(int A, int B, int K, Map<String, Long> dp) {
        if (A == 0 || B == 0 || K == 0) return 0;
        if (A == B && A == 1) return 1;

        String key = A + "," + B + "," + K;
        long val = dp.getOrDefault(key, -1L);
        if (val >= 0) return val;

        val = win((A + 1) >> 1, (B + 1) >> 1, (K + 1) >> 1, dp)
              + win((A + 1) >> 1, B >> 1, (K + 1) >> 1, dp)
              + win(A >> 1, (B + 1) >> 1, (K + 1) >> 1, dp)
              + win(A >> 1, B >> 1, K >> 1, dp);
        dp.put(key, val);
        return val;
    }

    // consider the most significant bit
    // Recursion
    // time complexity: O(LOG(MAX(A, B)))
    public static long win2(int A, int B, int K) {
        return dfs(A - 1, B - 1, K - 1, 30);
    }

    private static long dfs(long A, long B, long K, int p) {
        if (p < 0) return 1L;

        long a = (A >>> p) & 1;
        long b = (B >>> p) & 1;
        long mask = (1 << p) - 1;
        if (((K >>> p) & 1) == 1) {
            long res = (A + 1) * (B + 1);
            if ((a & b) == 1) {
                res -= ((A & mask) + 1) * ((B & mask) + 1);
                res += dfs(A & mask, B & mask, K & mask, p - 1);
            }
            return res;
        }
        if ((a | b) == 0) return dfs(A, B, K, p - 1);

        if (a == 0) {
            return dfs(A, mask, K, p - 1) + dfs(A, B & mask, K, p - 1);
        }
        if (b == 0) {
            return dfs(mask, B, K, p - 1) + dfs(A & mask, B, K, p - 1);
        }
        return dfs(A & mask, mask, K, p - 1) + dfs(mask, B & mask, K, p - 1)
               + dfs(mask, mask, K, p - 1);
    }

    void test(int A, int B, int K, long expected) {
        assertEquals(expected, win(A, B, K));
        assertEquals(expected, win2(A, B, K));
    }

    @Test
    public void test() {
        test(3, 4, 2, 10);
        test(4, 5, 2, 16);
        test(7, 8, 5, 52);
        test(45, 56, 35, 2411);
        test(103, 143, 88, 14377);

        test(843291372, 411173824, 497655158, 346739338171446528L);
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintStream out = System.out;
        if (args.length == 0) {
            String clazz =
                new Object() {}.getClass().getEnclosingClass().getSimpleName();
            out.format("Usage: java %s input_file [output_file]%n%n", clazz);
            org.junit.runner.JUnitCore.main(clazz);
            return;
        }
        try {
            in = new Scanner(new File(args[0]));
            if (args.length > 1) {
                out = new PrintStream(args[1]);
            }
        } catch (Exception e) {
            System.err.println(e);
            return;
        }

        int t = in.nextInt();
        for (int i = 1; i <= t; i++) {
            out.format("Case #%d: ", i);
            printResult(in, out);
        }
    }

    private static void printResult(Scanner in, PrintStream out) {
        int A = in.nextInt();
        int B = in.nextInt();
        int K = in.nextInt();
        out.println(win2(A, B, K));
    }
}
